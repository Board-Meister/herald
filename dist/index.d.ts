// Generated by dts-bundle-generator v9.5.1

interface EntryConfig {
	source: string | object;
	namespace: string;
	name: string;
	version: string;
	arguments?: unknown[];
}
interface RegisterConfig {
	entry: EntryConfig;
	type: "scope" | "module";
	scope?: boolean;
	tags?: string[];
	requires?: string[];
	lazy?: boolean;
	asset?: {
		src: string;
	};
	resource?: {
		src: string;
	};
}
declare class CModule<T = any> {
	constructor(...args: unknown[]);
	inject?: (injections: T) => void;
}
type Module<T = any> = CModule<T> | Record<string, unknown>;
interface IModuleImportObject {
	default?: Module | ((...args: unknown[]) => void);
}
interface IModuleImport {
	config: RegisterConfig;
	module: IModuleImportObject | (() => Promise<Module>);
}
declare class _IInjectable<T = object> {
	constructor(...args: unknown[]);
	inject(injections: T): void;
	scope?(): Record<string, unknown>;
	static inject: Record<string, string>;
}
type IInjectable<T> = typeof _IInjectable<T>;
declare class Marshal {
	static version: string;
	registered: Record<string, RegisterConfig>;
	loaded: Record<string, object>;
	tagMap: Record<string, IModuleImport[]>;
	scope: Record<string, unknown>;
	instanceMap: WeakMap<Module<any>, RegisterConfig>;
	constructor();
	addScope(name: string, value: unknown): void;
	register(config: RegisterConfig): void;
	getModuleConstraint(config: RegisterConfig): string;
	get<Type>(key: string): Type | null;
	load(): Promise<void>;
	loadScopes(): Promise<Record<string, RegisterConfig>>;
	updateTagModules(): void;
	tagModules(moduleImport: IModuleImport): void;
	instantiateModule(moduleImport: IModuleImport): Module;
	mapInstance(config: RegisterConfig, module: Module): void;
	getMappedInstance(module: Module): RegisterConfig | undefined;
	loadDependencies(module: Module, config: RegisterConfig): Record<string, object> | undefined | false;
	isESClass(fn: unknown): boolean;
	orderModules(moduleRegistry: Record<string, RegisterConfig>): RegisterConfig[];
	generateLoadGroups(toSend: Record<string, RegisterConfig>): Promise<IModuleImport>[];
	isTag(string: string): boolean;
	import(source: string, addScope?: Record<string, unknown>): Promise<IModuleImportObject>;
	importModule(config: RegisterConfig): Promise<IModuleImportObject>;
	retrieveModulePromise(config: RegisterConfig): Promise<IModuleImport>;
	isObjectEmpty(obj: object): boolean;
}
declare class _ISubscriber {
	static subscriptions: Subscriptions;
}
export type ISubscriber = typeof _ISubscriber;
export type AmbiguousSubscription = string | Subscription | Subscription[] | EventHandler;
export type EventHandler = (event: CustomEvent) => Promise<any> | any;
export type Subscriptions = Record<string, AmbiguousSubscription>;
export interface Subscription {
	method: string | EventHandler;
	priority?: number;
	constraint?: string | Module | null;
	index?: number;
}
export interface ISubscriberObject {
	module: ISubscriber;
	config: RegisterConfig;
}
export interface IEventRegistration {
	event: string;
	subscription: AmbiguousSubscription;
	constraint?: string | Module | null;
	sort?: boolean;
	symbol?: symbol | null;
}
interface IInjection extends Record<string, object | undefined> {
	subscribers: ISubscriberObject[];
	marshal?: Marshal;
}
export declare class Herald {
	#private;
	static inject: Record<string, string>;
	inject(injections: IInjection): void;
	dispatch(event: CustomEvent): Promise<void>;
	dispatchSync(event: CustomEvent): void;
	batch(events: IEventRegistration[]): () => void;
	register(event: string, subscription: AmbiguousSubscription, constraint?: string | Module | null, sort?: boolean, symbol?: symbol | null): () => void;
	unregister(event: string, symbol: symbol): void;
}
declare const EnHerald: IInjectable<IInjection>;

export {
	EnHerald as default,
};

export {};
